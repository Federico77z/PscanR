---
title: "Introduction to PscanR"
author: "Diana Betelli"
date: "`r Sys.Date()`"
output:
  BiocStyle::html_document:
    toc: true
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{2. Introduction to PscanR}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 80
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

**PscanR** is an R implementation of the algorithm developed by Zambelli et al.
(2009) for analyzing sequence motif enrichment. It helps identify transcription
factors (TFs) that are potential regulators of a set of co-regulated or
co-expressed genes. By scanning input sequences (e.g., promoters) against a
database of known TF binding motifs, **PscanR** assesses which motifs are
significantly over- or under- represented and highlights candidate binding
sites.

## Workflow overview:

***Input***: A set of DNA sequences (e.g., promoter regions) and a library of
known transcription factors binding motif, such as Position Weight Matrices
(PWMs) from the JASPAR database.

***Analysis***: Identification of enriched motif and calculation of statistical
significance (Z-scores and P-Values).

***Output***: A ranked list of enriched motif, along with their associated
P-Values and Z-scores.

# The Main Functions

Currently, the PscanR package implements two functions for the manipulation of
promoter regions: `pscan()` and `pscan_fullBG()`.

`pscan()` takes as input a DNAStringSet object containing the set of regulatory
sequences from co-regulated or co-expressed genes (i.e. a set of gene promoters)
and a PSMatrixList object containing PWMs and background statistics (e.g., the
standard deviation and average of hits scores when all the promoters in the
organism of study are scanned with the position weight matrices).

`pscan_fullBG()` can work if a full background is available (note: no full
backgrounds are included in the packages), containing scores, positions,
oligonucleotide sequences, and strand information for all promoter sequences of
a given organism (scanned using a Position Weight Matrix). The other input is a
vector containing the sequence identifiers (for the transcript) for the organism
of study.

# The Background Model

In order to assess the significance of the obtained result, a background model
must be computed in the form of a PSMatrixList object. In other methods the
background is generated by shuffling the columns of the motif or by building
random sequence sets of the same size and length of the sequence set
investigated.

In PscanR, instead, the input sequences are considered a sample drawn from a
universe consisting of all promoter sequences available for the species under
investigation. This *universe* serves as the background model for statistical
analyses, ensuring a comprehensive and unbiased assessment of the analysis
outcomes.

## Pre-computed background models

For convenience, several background models have already been computed and
optimized to meet common research needs. Precomputed backgrounds are stored in a
public repository at <https://github.com/dianabetelli/PscanR_backgrounds> for
the following species:

-   *Homo sapiens* (both hg38 and hs1 assembly)

-   *Mus musculus* (both mm10 and mm39)

-   *Arabidopsis thaliana* (TAIR9)

-   *Drosophila melanogaster* (dm6)

-   *Saccharomyces cerevisiae* (sacCer3).

The promoter regions analyzed in relation to the transcription start site (TSS)
include:

-   200 bp upstream and 50 bp downstream

-   450 bp upstream and 50 bp downstream

-   500 bp upstream and 0 bp downstream

-   950 bp upstream and 50 bp downstream

-   1000 bp upstream and 0 bp downstream

Background scores were generated using motif matrices from the JASPAR databases
for the 2020, 2022, and 2024 releases. Only **core motifs** from JASPAR are used
in the analysis.

### Loading a Pre-Computed Background

To load a pre-computed background model, PscanR provides a dedicated function to
retrieve the .txt files stored in the PscanR_backgrounds repository and generate
the required PSMatrixList. This requires specifying the JASPAR release, species
acronym, promoter region definition, and genome assembly (the last step only for
Mus musculus and Homo sapiens). Refer to the previous paragraph for the
available backgrounds.

```{r}
J2020_PSBG <- PscanR::generate_psmatrixlist_from_background('Jaspar2020', 'hs',                                                             c(-200,50), 'hg38') 
J2020_PSBG[[4]] # An example of Matrix
```

For more details on function parameters and usage, please refer to the PscanR
documentation.

## Generating Custom Backgrounds

To ensure flexibility and allow users to create **custom background models**
tailored to their specific experimental conditions, **PscanR** provides a
dedicated vignette. This resource guides users through the process of generating
background models optimized for their research needs.

For detailed instructions, please refer to the **PscanR** vignette 'How to
Generate a Background Model for PscanR algorithm'.

# The Input Transcript For `pscan()`

**`pscan()`** accepts as input a DNAStringSet object containing the DNA
sequences of co-regulated or co-expressed genes. This object can be built from a
list of gene/transcript identifiers.

For humans, mice, and Drosophila, the available background models are based on
RefSeq identifiers, for Arabidopsis on TAIR, and for yeast on SGD IDs. Other
types of gene identifiers can also be used if the corresponding background model
is created (see the vignette "How to Generate a Background Model for the PscanR
Algorithm" for more details).

Below is an example dataset containing **human NRF1 target transcripts**
(RefSeq), curated from the literature. Since PscanR works at the transcript
level, gene identifiers must be converted to their corresponding transcript IDs
before analysis. The number **100** indicates that 100% transcripts in the list
correspond to known NRF1 target.

```{r}
file_path <- system.file("extdata", "nrf1100.txt", 
                         package = "PscanR")
target <- read.csv(file_path, header = FALSE)
head(target)
```

## Gene IDs - Transcript IDs conversion

Since the functions work with Transcript IDs, we provide different pipelines for
various organism to help users in the conversion from Gene IDs.

### ENSEMBL

For ENSEMBL-based annotation, the biomaRt package can be used. Below is an
example for *Homo sapiens*.

```{r eval=FALSE, include=TRUE}
# Homo sapiens example 
mart <- biomaRt::useMart('ensembl', dataset = 'hsapiens_gene_ensembl')
GeneTranscript_ids <- biomaRt::getBM(attributes = 
                                       c('ensembl_gene_id',
                                         'ensembl_transcript_id',
                                         'transcript_tsl'),
                                     mart = mart) 
```

```{r eval = TRUE, include = FALSE}
path <- system.file('extdata', 'GeneTranscript_ids.rds', package = 'PscanR')
GeneTranscript_ids <- readRDS(path)
```

```{r}
head(GeneTranscript_ids)
```

This code chunk retrieves all gene identifiers for *Homo sapiens*, along with
the corresponding transcript IDs and their Transcript Support Level (TSL).

To slect only trasncripts with the highest level of experimental support, filter
by TSL1. This means that there is experimentally evidence that all the splice
junctions of the annotated transcript actually exist in the cells:

```{r}
genes <- c('ENSG00000271254', 'ENSG00000277196', 'ENSG00000277196')

transcripts <- GeneTranscript_ids[GeneTranscript_ids[,1] %in% genes & GeneTranscript_ids[,3] == 'tsl1',2]

transcripts
```

Change the dataset parameter according to the organism of study:

-   *Mus musculus*: 'mmusculus_gene_ensembl'

-   *Drosophila melanogaster*: 'dmelanogaster_gene_ensembl'. Note that for this
    organism the TSL attribute is not available.

## RefSeq

For RefSeq-based annotations, the AnnotationDbi package can be used together
with organism specific packages. Here's an example with `org.Dm.eg.db` for
*Drosophila melanogaster*.

```{r}
library(org.Dm.eg.db)
library(dplyr)

genes <- c('CG46191', 'dbr', 'Pp1-Y2')

transcripts <- AnnotationDbi::select(org.Dm.eg.db,
                                        keys = genes, 
                                        keytype = 'SYMBOL', # Entrez can be used
                                        columns = 'REFSEQ') %>% filter(grepl('^NM_', REFSEQ))

transcripts
```

For other organisms:

-   *Homo sapiens*: use the `org.Hs.eg.db` library

-   *Mus musculus*: use the `org.Mm.ge.db` library

## TAIR

In *Arabidopsis thaliana*, transcript ids are generated by appending the isoform
number to the gene id, after a dot (e.g., `AT1G01010.1`, `AT1G01010.2`). If you
want to know how many different isoforms are present for a transcript, you can
either download TAIR GFF files or you can use the biomaRt package via ENSEMBL
plants:

```{r}
ensembl_plants <- biomaRt::useMart('plants_mart', dataset = 'athaliana_eg_gene', host = 'https://plants.ensembl.org')
tair_genes <- c('AT1G01010', 'AT1G01020')
transcript_map <- biomaRt::getBM(
  attributes = c('tair_locus', 'ensembl_transcript_id'),
  filters = 'tair_locus',
  values = tair_genes,
  mart = ensembl_plants
)

transcript_map
```

## SGD

In *Saccharomyces cerevisiae*, genes are often referred to by their **systematic
ORF IDs** (e.g., `YPR195C`). If you have **gene symbols**, you can convert them
as shown below. Note that not all the systematic IDs have the corresponding
symbol.

```{r}
library(org.Sc.sgd.db)
gene_symbols <- c('TIF5', 'CDC28', 'RPL3')

ORF <- AnnotationDbi::select(org.Sc.sgd.db,
                             keys = gene_symbols,
                             columns = c('ORF', 'GENENAME'),
                             keytype = 'GENENAME')

ORF # take the second column for systematic ids
```

# The Input Promoters

## Promoter Regions

Promoter regions are specific DNA sequences located near the transcription start
site (TSS) of a gene. They serve as binding sites for transcription factors and
RNA polymerase, playing a crucial role in the regulation of gene expression.
Typically, promoter regions extend both upstream and slightly downstream of the
TSS.

In **R**, promoter regions can be extracted using genomic annotation tools, such
as the **GenomicFeatures** package. The following example demonstrates how to
retrieve promoter regions from a **transcript database (txdb)**:

```{r eval=FALSE, include=TRUE}
txdb <- txdbmaker::makeTxDbFromUCSC(genome="hg38", 
                                    tablename="ncbiRefSeqCurated")
# use only canonical chromosomes 
GenomeInfoDb::seqlevels(txdb) <- GenomeInfoDb::seqlevels(txdb)[1:24] 
prom_rng <- GenomicFeatures::promoters(txdb, 
                                       upstream = 200, 
                                       downstream = 50, 
                                       use.names = TRUE)
```

This code extracts regions **200 bp upstream and 50 bp downstream** of the TSS
for all annotated genes in the **Homo sapiens (hg38)** assembly.

For reproducibility, this vignette uses a precomputed dataset (`promoters.rds`)
instead of retrieving promoters from UCSC, which requires an internet connection
and may be subject to database updates.

```{r echo=FALSE}
promoters_path <- system.file("extdata", "promoters.rds", 
                         package = "PscanR")
prom_rng <- readRDS(promoters_path)
prom_rng
```

#### **Processing Promoter Identifiers**

Ensure that your target identifiers match those in `prom_rng$tx_name_clean`. If
your dataset contains gene symbols instead of transcript IDs, convert them using
annotation tools (e.g., `AnnotationDbi` with `org.Hs.eg.db`).

In this example, the list of target transcripts does not include version numbers
(e.g., *NM_002188* instead of *NM_002188.1*). Therefore, we need to remove
version numbers from `prom_rng$tx_name` before filtering promoter regions:

```{r}
prom_rng$tx_name_clean <- sub("\\..*$", "", prom_rng$tx_name)
target_prom_rng <- prom_rng[prom_rng$tx_name_clean %in% target[,1]]
```

#### **Retrieving Promoter Sequences**

Once the promoter regions are defined, their corresponding DNA sequences can be
extracted from the reference genome using, for example, **Biostrings** and
**BSgenome**:

```{r}
prom_seq <- Biostrings::getSeq(
  x = BSgenome.Hsapiens.UCSC.hg38::BSgenome.Hsapiens.UCSC.hg38, 
  target_prom_rng)
prom_seq
```

# The algorithm

**PscanR** performs **motif enrichment analysis** by computing **alignment
scores** between regulatory sequences (e.g., gene promoters) and **Position
Weight Matrices** (PWMs). The algorithm evaluates both the forward and reverse
complement strands, ensuring that no potential transcription factor binding
sites are missed.

To execute the motif scan, use the following function:

```{r}
results <- PscanR::pscan(prom_seq, J2020_PSBG, 
                 BPPARAM = BiocParallel::SnowParam(1)) 
```

The method scans each input sequence by extracting all possible **k-mers**
(substrings of length *k*, where *k* is the length of the PWM motif). For each
k-mer a score is computed for both the forward and reverse strand based on how
well the k-mer matches the Transcription Factor Binding Motif provided by the
PWM. For each sequence-PWM pair, only the k-mer with the highest score is
retained.

To assess motif enrichment, the foreground average score (the mean of the scores
for a PWM) for each PSM is compared with the background average score and
standard deviation (contained in the background PSMatrixList) to compute z-score
and pvalue.

### Parallel Computation in PscanR

**PscanR** supports **parallel computation** to enhance performance when
analyzing large datasets. The function `pscan()` utilizes the **BiocParallel**
package, which enables users to specify different parallelization strategies via
the `BPPARAM` argument.

#### **SnowParam vs. MulticoreParam**

-   **SnowParam:** (used in the example above) relies on distributed memory
    computing, making it compatible with all operating systems, including
    windows.

-   **MulticoreParam:** uses **forking**, which is generally faster but is only
    supported on **Unix-based systems (Linux/macOS)**.

To use **MulticoreParam** instead of **SnowParam**, modify the function call as
follows (recommended for Unix-based systems):

```{r eval=FALSE, include=TRUE}
results <- PscanR::pscan(prom_seq, J2020_PSBG, 
                 BPPARAM = BiocParallel::MulticoreParam(8)) 
```

Here, 8 specifies the number of CPU cores to be used. Adjust this number based
on system capacity for optimal performance. Note that the default BPPARAM value
in `pscan()` is `bpparam()`, which automatically selects the parallelization
type and the number of cores based on the system from which the command is
executed.

For a detailed comparison of computational efficiency with different numbers of
cores, refer to the vignette: **"Comparing Execution Time with Varying
Processors"**.

# Interpretation of results

To visualize the statistics of the different results, run the chunk of code
below:

```{r}
table <- PscanR::ps_results_table(results) 
head(table)
```

The `ps_results_table()` function returns a data.frame with matrices ordered by
increasing P.VALUE and decreasing ZSCORE, prioritizing significant and strongly
enriched motifs.

It contains the following columns:

-   "NAME": The name of the transcription factors

-   "BG_AVG": The average background score for each PWM.

-   "BG_STDEV": The standard deviation of the background scores for each PWM.

-   "FG_AVG": The average foreground score for each PWM.

-   "**ZSCORE**": The Z-score for each PWM. It indicates the degree of motif
    enrichment. A higher score suggests stronger enrichment.

-   "**P.VALUE**": The p-value for each PWM. It provides the statistical
    significance of the results. Smaller values indicates more significant
    results.

-   "FDR": The adjusted p-value (False Discovery Rate) calculated using the
    Benjamini-Hochberg correction.

Rows contain matrices names retrieved from the JASPAR database, 2020 release.

## Score Correlation Map

```{r}
PscanR::ps_zscore_heatmap(results, FDR = 0.01)
```

The command above plots correlations with a False Discovery Rate (FDR) threshold
of 0.01, which means only statistically significant correlations are shown. To
interpret this plot you can follow the color scale:

-   Red: Positive correlation.

-   Blue: Negative correlation.

-   White/gray: Neutral or weak correlation.

Interpretation: transcripts with similar expression patterns are clustered
together. Red clusters represent co-regulated transcripts, whereas blue clusters
indicate transcripts that are negatively correlated (when one is up-regulated
the other is down-regulated).

As we can see, NRF1 is highly enriched in all the promoter regions (red color
for all the rows). This is expected behaviour since all the analysed promoter
regions are known to be bound by the transcription factor.

## Hits Position Heatmap

```{r}
PscanR::ps_hitpos_map(results, FDR = 0.01, shift = -200)
```

This heatmap represents the distribution of hits (binding events) for different
transcription factors (TFs) across various promoter sequences. On the x axis we
find the TFs, whereas the y axis represents the promoter sequences retrieved
from a dataset.

Red areas indicate binding events near the TSS, while lighter colors indicate
farthest binding events on the analysed sequences.

## Density plot

This plot analyse the binding site distribution across the promoter region of
the analysed sequences for NRF1 transcription factor.

```{r}
pfm1 <- results[['MA0506.1']]
PscanR::ps_density_plot(pfm1, shift = -200)
```

This density plot visualizes the distribution of binding sites for the
transcription factor **NRF1** across **86 promoter sequences**, selected to have
a score greater than the background average value. In this example, the studied
length of promoter region is around 250 bp, between 200 bp before the TSS and 50
bp after.

The highest density of NRF1 binding occurs around **position -36 bp** along the
promoters (marked by the dashed vertical line). Another peak is in the region
-150/-200 bp.

## Bubble chart

```{r}
PscanR::ps_score_position_BubbleChart(results[['MA0506.1']], shift = -200)
```

This plot visualizes the distribution of binding scores by position for a given
transcription factor (e.g., NRF1), allowing to inspect both binding affinity and
position preferences across all input promoter sequences.

-   X-axis: Position relative to the TSS (placed on 0)

-   Y-axis: Hit scores. Higher values suggest stronger motif enrichment.

-   Bubble size: Indicates the number of binding site hits at a given position
    range and score.

-   Colored horizontal lines:

    -   Background average score (red dashed line)

    -   Standard deviation range (delimited by orange dashed lines)

    -   Foreground average score (green solid line)

```{r}
# Display session information
sessionInfo()
```
