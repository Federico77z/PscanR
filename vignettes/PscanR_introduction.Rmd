---
title: "Introduction to PscanR"
author: "Diana Betelli"
date: "`r Sys.Date()`"
output:
  BiocStyle::html_document:
    toc: true
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{1. Introduction to PscanR}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 80
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

**PscanR** is an R implementation of the algorithm developed by Zambelli et al.
(2009) for analyzing sequence motif enrichment. It helps identify transcription
factors (TFs) that are potential regulators of a set of co-regulated or
co-expressed genes. By scanning input sequences (e.g., promoters) against a
database of known TF binding motifs, **PscanR** assesses which motifs are
significantly over- or under- represented and highlights candidate binding
sites.

## Workflow overview:

***Input***: A set of DNA sequences (e.g., promoter regions) and a library of
known transcription factors binding motif, such as Position Weight Matrices
(PWMs) from the JASPAR database.

***Analysis***: Identification of enriched motif and calculation of statistical
significance (Z-scores and P-Values).

***Output***: A ranked list of enriched motif, along with their associated
P-Values and Z-scores.

# The Main Functions

Currently, the PscanR package implements two functions for the manipulation of
promoter regions: `pscan()` and `pscan_fullBG()`.

`pscan()` takes as input a DNAStringSet object containing the set of regulatory
sequences from co-regulated or co-expressed genes 
(i.e. a set of gene promoters) and a PSMatrixList object containing PWMs and 
background statistics (e.g., the standard deviation and average of hits scores 
when all the promoters in the organism of study are scanned with the position 
weight matrices).

`pscan_fullBG()` can work if a full background is available (note: no full
backgrounds are included in the packages), containing scores, positions,
oligonucleotide sequences, and strand information for all promoter sequences of
a given organism (scanned using a Position Weight Matrix). The other input is a
vector containing the sequence identifiers (for the transcript) for the 
organism of study.

# The Background Model

In order to assess the significance of the obtained result, a background model
must be computed in the form of a PSMatrixList object. In other methods the
background is generated by shuffling the columns of the motif or by building
random sequence sets of the same size and length of the sequence set
investigated.

In PscanR, instead, the input sequences are considered a sample drawn from a
universe consisting of all promoter sequences available for the species under
investigation. This *universe* serves as the background model for statistical
analyses, ensuring a comprehensive and unbiased assessment of the analysis
outcomes.

## Pre-computed background models

For convenience, several background models have already been computed and
optimized to meet common research needs. Precomputed backgrounds are stored in 
a public repository at <https://github.com/dianabetelli/PscanR_backgrounds> for
the following species:

-   *Homo sapiens* (both hg38 and hs1 assembly)

-   *Mus musculus* (both mm10 and mm39)

-   *Arabidopsis thaliana* (TAIR9)

-   *Drosophila melanogaster* (dm6)

-   *Saccharomyces cerevisiae* (sacCer3).

The promoter regions analyzed in relation to the transcription start site (TSS)
include:

-   200 bp upstream and 50 bp downstream

-   450 bp upstream and 50 bp downstream

-   500 bp upstream and 0 bp downstream

-   950 bp upstream and 50 bp downstream

-   1000 bp upstream and 0 bp downstream

Background scores were generated using motif matrices from the JASPAR databases
for the 2020, 2022, and 2024 releases. Only **core motifs** from JASPAR are 
used in the analysis.

### Loading a Pre-Computed Background

To load a pre-computed background model, PscanR provides a dedicated function 
to retrieve the .txt files stored in the PscanR_backgrounds repository and 
generate the required PSMatrixList. 
This requires specifying the JASPAR release, species acronym, promoter region 
definition, and genome assembly (the last step only for Mus musculus and Homo 
sapiens). 
Refer to the previous paragraph for the available backgrounds.

```{r}
J2020_PSBG <- PscanR::generate_psmatrixlist_from_background('Jaspar2020', 'hs',                                                             c(-200,50), 'hg38') 
J2020_PSBG[[4]] # An example of Matrix
```

For more details on function parameters and usage, please refer to the PscanR
documentation.

## Generating Custom Backgrounds

To ensure flexibility and allow users to create **custom background models**
tailored to their specific experimental conditions, **PscanR** provides a
dedicated vignette. This resource guides users through the process of 
generating background models optimized for their research needs.

For detailed instructions, please refer to the **PscanR** vignette 'How to
Generate a Background Model for PscanR algorithm'.

# The Input Transcript For `pscan()`

**`pscan()`** accepts as input a DNAStringSet object containing the DNA
sequences of co-regulated or co-expressed genes. This object can be built from 
a list of gene/transcript identifiers.

For humans, mice, and Drosophila, the available background models are based on
RefSeq identifiers, for Arabidopsis on TAIR, and for yeast on SGD IDs. Other
types of gene identifiers can also be used if the corresponding background 
model is created (see the vignette "How to Generate a Background Model for the 
PscanR Algorithm" for more details).

Below is an example dataset containing **human NF-κB target transcripts**
(RefSeq), curated from the literature. Since PscanR works at the transcript
level, gene identifiers must be converted to their corresponding transcript IDs
before analysis. The number **50** indicates that 50% transcripts in the list
correspond to known NF-κB target genes.

```{r}
file_path <- system.file("extdata", "nfkb50.txt", 
                         package = "PscanR")
target <- read.csv(file_path, header = FALSE)
```

# The Input Promoters

## Promoter Regions

Promoter regions are specific DNA sequences located near the transcription 
start site (TSS) of a gene. They serve as binding sites for transcription 
factors and RNA polymerase, playing a crucial role in the regulation of gene 
expression. Typically, promoter regions extend both upstream and slightly 
downstream of the TSS.

In **R**, promoter regions can be extracted using genomic annotation tools, 
such as the **GenomicFeatures** package. 
The following example demonstrates how to retrieve promoter regions from 
a **transcript database (txdb)**:

```{r eval=FALSE, include=TRUE}
txdb <- txdbmaker::makeTxDbFromUCSC(genome="hg38", 
                                    tablename="ncbiRefSeqCurated")
# use only canonical chromosomes 
GenomeInfoDb::seqlevels(txdb) <- GenomeInfoDb::seqlevels(txdb)[1:24] 
prom_rng <- GenomicFeatures::promoters(txdb, 
                                       upstream = 200, 
                                       downstream = 50, 
                                       use.names = TRUE)
```

This code extracts regions **200 bp upstream and 50 bp downstream** of the TSS
for all annotated genes in the **Homo sapiens (hg38)** assembly.

For reproducibility, this vignette uses a precomputed dataset (`promoters.rds`)
instead of retrieving promoters from UCSC, which requires an internet 
connection and may be subject to database updates.

```{r echo=FALSE}
promoters_path <- system.file("extdata", "promoters.rds", 
                         package = "PscanR")
prom_rng <- readRDS(promoters_path)
prom_rng
```

#### **Processing Promoter Identifiers**

Ensure that your target identifiers match those in `prom_rng$tx_name_clean`. 
If your dataset contains gene symbols instead of transcript IDs, 
convert them using annotation tools 
(e.g., `AnnotationDbi` with `org.Hs.eg.db`).

In this example, the list of target transcripts does not include version 
numbers (e.g., *NM_002188* instead of *NM_002188.1*). 
Therefore, we need to remove version numbers from `prom_rng$tx_name` before 
filtering promoter regions:

```{r}
prom_rng$tx_name_clean <- sub("\\..*$", "", prom_rng$tx_name)
target_prom_rng <- prom_rng[prom_rng$tx_name_clean %in% target[,1]]
```

#### **Retrieving Promoter Sequences**

Once the promoter regions are defined, their corresponding DNA sequences can be
extracted from the reference genome using, for example, **Biostrings** and
**BSgenome**:

```{r}
prom_seq <- Biostrings::getSeq(
  x = BSgenome.Hsapiens.UCSC.hg38::BSgenome.Hsapiens.UCSC.hg38, 
  target_prom_rng)
prom_seq
```

# The algorithm

**PscanR** performs **motif enrichment analysis** by computing **alignment
scores** between regulatory sequences (e.g., gene promoters) and **Position
Weight Matrices** (PWMs). The algorithm evaluates both the forward and reverse
complement strands, ensuring that no potential transcription factor binding
sites are missed.

To execute the motif scan, use the following function:

```{r}
results <- PscanR::pscan(prom_seq, J2020_PSBG, 
                 BPPARAM = BiocParallel::SnowParam(1)) 
```

The method scans each input sequence by extracting all possible **k-mers**
(substrings of length *k*, where *k* is the length of the PWM motif). For each
k-mer a score is computed for both the forward and reverse strand based on how
well the k-mer matches the Transcription Factor Binding Motif provided by the
PWM. For each sequence-PWM pair, only the k-mer with the highest score is
retained.

To assess motif enrichment, the foreground average score (the mean of the 
scores for a PWM) for each PSM is compared with the background average score 
and standard deviation (contained in the background PSMatrixList) to compute 
z-score and pvalue.

### Parallel Computation in PscanR

**PscanR** supports **parallel computation** to enhance performance when
analyzing large datasets. The function `pscan()` utilizes the **BiocParallel**
package, which enables users to specify different parallelization strategies 
via the `BPPARAM` argument.

#### **SnowParam vs. MulticoreParam**

-   **SnowParam:** (used in the example above) relies on distributed memory
    computing, making it compatible with all operating systems, including
    windows.

-   **MulticoreParam:** uses **forking**, which is generally faster but is only
    supported on **Unix-based systems (Linux/macOS)**.

To use **MulticoreParam** instead of **SnowParam**, modify the function call as
follows (recommended for Unix-based systems):

```{r eval=FALSE, include=TRUE}
results <- PscanR::pscan(prom_seq, J2020_PSBG, 
                 BPPARAM = BiocParallel::MulticoreParam(8)) 
```

Here, 8 specifies the number of CPU cores to be used. Adjust this number based
on system capacity for optimal performance. Note that the default BPPARAM value
in `pscan()` is `bpparam()`, which automatically selects the parallelization
type and the number of cores based on the system from which the command is
executed.

For a detailed comparison of computational efficiency with different numbers of
cores, refer to the vignette: **"Comparing Execution Time with Varying
Processors"**.

# Interpretation of results

To visualize the statistics of the different results, run the chunk of code
below:

```{r}
table <- PscanR::ps_results_table(results) 
head(table)
```

The `ps_results_table()` function returns a data.frame with matrices ordered by
increasing P.VALUE and decreasing ZSCORE, prioritizing significant and strongly
enriched motifs.

It contains the following columns:

-   "NAME": The name of the transcription factors

-   "BG_AVG": The average background score for each PWM.

-   "BG_STDEV": The standard deviation of the background scores for each PWM.

-   "FG_AVG": The average foreground score for each PWM.

-   "**ZSCORE**": The Z-score for each PWM. It indicates the degree of motif
    enrichment. A higher score suggests stronger enrichment.

-   "**P.VALUE**": The p-value for each PWM. It provides the statistical
    significance of the results. Smaller values indicates more significant
    results.

-   "FDR": The adjusted p-value (False Discovery Rate) calculated using the
    Benjamini-Hochberg correction.

Rows contain matrices names retrieved from the JASPAR database, 2020 release.

## Score Correlation Map

```{r}
PscanR::ps_zscore_heatmap(results, FDR = 0.01)
```

The command above plots correlations with a False Discovery Rate (FDR) 
threshold of 0.01, which means only statistically significant correlations 
are shown. 
To interpret this plot you can follow the color scale:

-   Red: Positive correlation.

-   Blue: Negative correlation.

-   White/gray: Neutral or weak correlation.

Interpretation: transcripts with similar expression patterns are clustered
together. Red clusters represent co-regulated transcripts, whereas blue 
clusters indicate transcripts that are negatively correlated 
(when one is up-regulated the other is down-regulated).

## Hits Position Heatmap

```{r}
PscanR::ps_hitpos_map(results, FDR = 0.01)
```

This heatmap represent the distribution of hits (binding events) for different
transcription factors (TFs) across various promoter sequences. On the x axis we
find the TFs, whereas the y axis represents the promoter sequences retrieved
from a dataset.

The color gradient reflects the binding affinity: red areas indicate strong TF
binding affinity at specific promoter sequences, while lighter colors indicate
weaker binding.

## Density plot

```{r}
pfm1 <- results[[1]]
PscanR::ps_density_plot(pfm1)
```

This density plot visualizes the distribution of binding sites for the
transcription factor **Arnt** across **56 promoter sequences**. 
In this example, the studied length of promoter region is around 250 bp, 
between 200 bp before the TSS and 50 bp after.

The highest density of Arnt binding occurs around **position 77** along the
promoters (marked by the dashed vertical line). This suggest a preferential
binding region between the first 100 bp of the promoter region. Another broad
peak is observed between 100 and 200 bp, indicating a potential secondary
binding region.

```{r}
# Display session information
sessionInfo()
```
